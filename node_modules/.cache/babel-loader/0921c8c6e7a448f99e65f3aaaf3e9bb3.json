{"ast":null,"code":"import { createAction } from 'redux-actions';\nimport * as api from '../../API';\nexport const getArticlesProcess = createAction('GET_ARTICLES_PROCESS');\nexport const getArticlesSuccess = createAction('GET_ARTICLES_SUCCESS'); // при запросе на сервер статьи возвращаются пачками размером articlesPerRequest\n// в ответе приходит { articles: [], articlesCount: value }\n// массив articles диспатчим, чтобы не ждать от сервера все статьи(вдруг их тысячи)\n// Каждую итерацию сравниваем уже полученное число статей и кол-во на сервере\n// если на сервере статьи еще есть, то на фоне делаем запросы для их получения\n\nexport const getArticles = () => async dispatch => {\n  let currentArticlesCounter = 0;\n\n  const fetchArticles = async (articlesPerRequest = 100, counter = 0) => {\n    const response = await api.getArticles(articlesPerRequest, counter);\n    const {\n      articles,\n      articlesCount\n    } = response;\n    dispatch(getArticlesProcess(articles));\n    currentArticlesCounter += articles.length;\n\n    if (currentArticlesCounter < articlesCount) {\n      await fetchArticles(articlesPerRequest, currentArticlesCounter);\n    }\n\n    if (currentArticlesCounter === articlesCount) {\n      dispatch(getArticlesSuccess());\n    }\n  };\n\n  await fetchArticles();\n}; // создать пост\n\nexport const createArticleRequest = createAction('CREATE_ARTICLE_REQUEST');\nexport const createArticleSuccess = createAction('CREATE_ARTICLE_SUCCESS');\nexport const createArticleFailure = createAction('CREATE_ARTICLE_FAILURE');\nexport const createArticle = (articleBody, formik) => async dispatch => {\n  dispatch(createArticleRequest());\n\n  try {\n    await api.createArticle(articleBody, formik);\n    dispatch(createArticleSuccess());\n  } catch (error) {\n    dispatch(createArticleFailure());\n  }\n}; // запросить 1 пост\n// этот экшен нужен, чтобы загрузить пост просматриваемый пользователем\n// если он вбивает ссылку на пост в адресной строке\n\nexport const getOneArticleRequest = createAction('GET_ONE_ARTICLE_REQUEST');\nexport const getOneArticleSuccess = createAction('GET_ONE_ARTICLE_SUCCESS');\nexport const getOneArticleFailure = createAction('GET_ONE_ARTICLE_FAILURE');\nexport const getOneArticle = queryParam => async dispatch => {\n  dispatch(getOneArticleRequest());\n\n  try {\n    const response = await api.getOneArticle(queryParam);\n    dispatch(getOneArticleSuccess(response));\n  } catch (error) {\n    dispatch(getOneArticleFailure());\n    throw error;\n  }\n}; // изменить пост\n\nexport const editArticleRequest = createAction('EDIT_ARTICLE_REQUEST');\nexport const editArticleSuccess = createAction('EDIT_ARTICLE_SUCCESS');\nexport const editArticleFailure = createAction('EDIT_ARTICLE_FAILURE');\nexport const editArticle = (articleData, queryParam, formik) => async dispatch => {\n  dispatch(editArticleRequest());\n\n  try {\n    await api.editArticle(articleData, queryParam, formik);\n    dispatch(editArticleSuccess());\n  } catch (error) {\n    dispatch(editArticleFailure);\n    throw error;\n  }\n}; // лайк поста\n\nexport const addLikeRequest = createAction('ADD_LIKE_REQUEST');\nexport const addLikeSuccess = createAction('ADD_LIKE_SUCCESS');\nexport const addLikeFailure = createAction('ADD_LIKE_FAILURE');\nexport const refreshLikeInArticlesArray = createAction('REFRESH_LIKE_IN_ARTICLES_ARRAY');\nexport const addLike = likeBody => async dispatch => {\n  if (!likeBody.isRepeatedRequest) {\n    dispatch(refreshLikeInArticlesArray(likeBody.id));\n  } // запрещаем отправку на сервер если лайк уже отправлен\n\n\n  if (likeBody.isAlreadyRequested) return;\n  dispatch(addLikeRequest(likeBody.id));\n\n  try {\n    const response = await api.addLike(likeBody);\n    dispatch(addLikeSuccess(response));\n  } catch (error) {\n    dispatch(addLikeFailure());\n    throw error;\n  }\n}; // удалить пост\n\nexport const removeArticleRequest = createAction('REMOVE_ARTICLE_REQUEST');\nexport const removeArticleSuccess = createAction('REMOVE_ARTICLE_SUCCESS');\nexport const removeArticleFailure = createAction('REMOVE_ARTICLE_FAILURE');\nexport const removeArticle = queryParam => async dispatch => {\n  dispatch(removeArticleRequest());\n\n  try {\n    await api.removeArticle(queryParam);\n    dispatch(removeArticleSuccess());\n  } catch (error) {\n    dispatch(removeArticleFailure());\n    throw error;\n  }\n}; // обновить посты после создания нового поста / удаления / редактирования\n\nexport const refreshArticlesRequest = createAction('REFRESH_ARTICLES_REQUEST'); // обновить список постов\n\nexport const refreshArticles = () => async dispatch => {\n  dispatch(createArticleFailure());\n  dispatch(refreshArticlesRequest());\n  dispatch(editArticleFailure());\n  dispatch(getOneArticleFailure());\n  dispatch(removeArticleFailure());\n};","map":{"version":3,"sources":["C:/Users/stalk/jm-blog-platform/src/redux/actions/articles.js"],"names":["createAction","api","getArticlesProcess","getArticlesSuccess","getArticles","dispatch","currentArticlesCounter","fetchArticles","articlesPerRequest","counter","response","articles","articlesCount","length","createArticleRequest","createArticleSuccess","createArticleFailure","createArticle","articleBody","formik","error","getOneArticleRequest","getOneArticleSuccess","getOneArticleFailure","getOneArticle","queryParam","editArticleRequest","editArticleSuccess","editArticleFailure","editArticle","articleData","addLikeRequest","addLikeSuccess","addLikeFailure","refreshLikeInArticlesArray","addLike","likeBody","isRepeatedRequest","id","isAlreadyRequested","removeArticleRequest","removeArticleSuccess","removeArticleFailure","removeArticle","refreshArticlesRequest","refreshArticles"],"mappings":"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","sourcesContent":["import { createAction } from 'redux-actions';\nimport * as api from '../../API';\n\nexport const getArticlesProcess = createAction('GET_ARTICLES_PROCESS');\nexport const getArticlesSuccess = createAction('GET_ARTICLES_SUCCESS');\n// при запросе на сервер статьи возвращаются пачками размером articlesPerRequest\n// в ответе приходит { articles: [], articlesCount: value }\n// массив articles диспатчим, чтобы не ждать от сервера все статьи(вдруг их тысячи)\n// Каждую итерацию сравниваем уже полученное число статей и кол-во на сервере\n// если на сервере статьи еще есть, то на фоне делаем запросы для их получения\nexport const getArticles = () => async (dispatch) => {\n  let currentArticlesCounter = 0;\n\n  const fetchArticles = async (articlesPerRequest = 100, counter = 0) => {\n    const response = await api.getArticles(articlesPerRequest, counter);\n    const { articles, articlesCount } = response;\n    dispatch(getArticlesProcess(articles));\n\n    currentArticlesCounter += articles.length;\n    if (currentArticlesCounter < articlesCount) {\n      await fetchArticles(articlesPerRequest, currentArticlesCounter);\n    }\n    if (currentArticlesCounter === articlesCount) {\n      dispatch(getArticlesSuccess());\n    }\n  };\n  await fetchArticles();\n};\n\n// создать пост\nexport const createArticleRequest = createAction('CREATE_ARTICLE_REQUEST');\nexport const createArticleSuccess = createAction('CREATE_ARTICLE_SUCCESS');\nexport const createArticleFailure = createAction('CREATE_ARTICLE_FAILURE');\n\nexport const createArticle = (articleBody, formik) => async (dispatch) => {\n  dispatch(createArticleRequest());\n  try {\n    await api.createArticle(articleBody, formik);\n    dispatch(createArticleSuccess());\n  } catch (error) {\n    dispatch(createArticleFailure());\n  }\n};\n\n// запросить 1 пост\n// этот экшен нужен, чтобы загрузить пост просматриваемый пользователем\n// если он вбивает ссылку на пост в адресной строке\nexport const getOneArticleRequest = createAction('GET_ONE_ARTICLE_REQUEST');\nexport const getOneArticleSuccess = createAction('GET_ONE_ARTICLE_SUCCESS');\nexport const getOneArticleFailure = createAction('GET_ONE_ARTICLE_FAILURE');\n\nexport const getOneArticle = (queryParam) => async (dispatch) => {\n  dispatch(getOneArticleRequest());\n  try {\n    const response = await api.getOneArticle(queryParam);\n    dispatch(getOneArticleSuccess(response));\n  } catch (error) {\n    dispatch(getOneArticleFailure());\n    throw error;\n  }\n};\n\n// изменить пост\nexport const editArticleRequest = createAction('EDIT_ARTICLE_REQUEST');\nexport const editArticleSuccess = createAction('EDIT_ARTICLE_SUCCESS');\nexport const editArticleFailure = createAction('EDIT_ARTICLE_FAILURE');\n\nexport const editArticle = (articleData, queryParam, formik) => async (dispatch) => {\n  dispatch(editArticleRequest());\n  try {\n    await api.editArticle(articleData, queryParam, formik);\n    dispatch(editArticleSuccess());\n  } catch (error) {\n    dispatch(editArticleFailure);\n    throw error;\n  }\n};\n\n// лайк поста\nexport const addLikeRequest = createAction('ADD_LIKE_REQUEST');\nexport const addLikeSuccess = createAction('ADD_LIKE_SUCCESS');\nexport const addLikeFailure = createAction('ADD_LIKE_FAILURE');\n\nexport const refreshLikeInArticlesArray = createAction('REFRESH_LIKE_IN_ARTICLES_ARRAY');\n\nexport const addLike = (likeBody) => async (dispatch) => {\n  if (!likeBody.isRepeatedRequest) {\n    dispatch(refreshLikeInArticlesArray(likeBody.id));\n  }\n\n  // запрещаем отправку на сервер если лайк уже отправлен\n  if (likeBody.isAlreadyRequested) return;\n  dispatch(addLikeRequest(likeBody.id));\n  try {\n    const response = await api.addLike(likeBody);\n    dispatch(addLikeSuccess(response));\n  } catch (error) {\n    dispatch(addLikeFailure());\n    throw error;\n  }\n};\n\n\n// удалить пост\nexport const removeArticleRequest = createAction('REMOVE_ARTICLE_REQUEST');\nexport const removeArticleSuccess = createAction('REMOVE_ARTICLE_SUCCESS');\nexport const removeArticleFailure = createAction('REMOVE_ARTICLE_FAILURE');\n\nexport const removeArticle = (queryParam) => async (dispatch) => {\n  dispatch(removeArticleRequest());\n  try {\n    await api.removeArticle(queryParam);\n    dispatch(removeArticleSuccess());\n  } catch (error) {\n    dispatch(removeArticleFailure());\n    throw error;\n  }\n};\n\n// обновить посты после создания нового поста / удаления / редактирования\nexport const refreshArticlesRequest = createAction('REFRESH_ARTICLES_REQUEST');\n\n// обновить список постов\nexport const refreshArticles = () => async (dispatch) => {\n  dispatch(createArticleFailure());\n  dispatch(refreshArticlesRequest());\n  dispatch(editArticleFailure());\n  dispatch(getOneArticleFailure());\n  dispatch(removeArticleFailure());\n};\n"]},"metadata":{},"sourceType":"module"}