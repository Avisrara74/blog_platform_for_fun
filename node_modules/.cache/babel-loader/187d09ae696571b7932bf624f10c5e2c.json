{"ast":null,"code":"import { createAction } from 'redux-actions';\nimport * as api from '../../API';\nexport const signUpRequest = createAction('SIGN_UP_REQUEST');\nexport const signUpSuccess = createAction('SIGN_UP_SUCCESS');\nexport const signUpFailure = createAction('SIGN_UP_FAILURE'); // регистрация\n\nexport const signUp = (newUserData, formik) => async dispatch => {\n  dispatch(signUpRequest());\n\n  try {\n    await api.signUpProcess(newUserData, formik);\n    dispatch(signUpSuccess());\n  } catch (err) {\n    dispatch(signUpFailure());\n  }\n};\nexport const signInRequest = createAction('LOG_IN_REQUEST');\nexport const signInSuccess = createAction('LOG_IN_SUCCESS');\nexport const signInFailure = createAction('LOG_IN_FAILURE'); // авторизация\n\nexport const signIn = (userData, formik) => async dispatch => {\n  dispatch(signInRequest());\n\n  try {\n    const responseUserData = await api.signInProcess(userData, formik);\n    dispatch(signInSuccess(responseUserData));\n  } catch (err) {\n    dispatch(signInFailure());\n  }\n};\nexport const logOutSuccess = createAction('LOGOUT_SUCCESS');\nexport const getArticlesProcess = createAction('GET_ARTICLES_PROCESS');\nexport const getArticlesSuccess = createAction('GET_ARTICLES_SUCCESS'); // при запросе на сервер статьи возвращаются пачками размером articlesPerRequest\n// в ответе приходит { articles: [], articlesCount: value }\n// массив articles диспатчим, чтобы не ждать от сервера все статьи(вдруг их тысячи)\n// Каждую итерацию сравниваем уже полученное число статей и кол-во на сервере\n// если на сервере статьи еще есть, то на фоне делаем запросы для их получения\n\nexport const getArticles = () => async dispatch => {\n  let currentArticlesCounter = 0;\n\n  const fetchArticles = async (articlesPerRequest = 100, counter = 0) => {\n    const response = await api.getArticles(articlesPerRequest, counter);\n    const {\n      articles,\n      articlesCount\n    } = response;\n    dispatch(getArticlesProcess(articles));\n    currentArticlesCounter += articles.length;\n\n    if (currentArticlesCounter < articlesCount) {\n      await fetchArticles(articlesPerRequest, currentArticlesCounter);\n    }\n\n    if (currentArticlesCounter === articlesCount) {\n      dispatch(getArticlesSuccess());\n    }\n  };\n\n  try {\n    await fetchArticles();\n  } catch (error) {\n    console.log(error.response);\n  }\n}; // создать пост\n\nexport const createArticleRequest = createAction('CREATE_ARTICLE_REQUEST');\nexport const createArticleSuccess = createAction('CREATE_ARTICLE_SUCCESS');\nexport const createArticleFailure = createAction('CREATE_ARTICLE_FAILURE');\nexport const createArticle = (articleBody, formik) => async dispatch => {\n  dispatch(createArticleRequest());\n\n  try {\n    await api.createArticle(articleBody, formik);\n    dispatch(createArticleSuccess());\n  } catch (error) {\n    console.log(error);\n    dispatch(createArticleFailure());\n  }\n}; // запросить 1 пост\n// этот экшен нужен, чтобы загрузить пост просматриваемый пользователем\n// если он вбивает ссылку на пост в адресной строке\n\nexport const getOneArticleRequest = createAction('GET_ONE_ARTICLE_REQUEST');\nexport const getOneArticleSuccess = createAction('GET_ONE_ARTICLE_SUCCESS');\nexport const getOneArticleFailure = createAction('GET_ONE_ARTICLE_FAILURE');\nexport const getOneArticle = queryParam => async dispatch => {\n  dispatch(getOneArticleRequest());\n\n  try {\n    const response = await api.getOneArticle(queryParam);\n    dispatch(getOneArticleSuccess(response));\n  } catch (error) {\n    dispatch(getOneArticleFailure());\n    throw error;\n  }\n}; // обновить посты после создания нового поста / удаления / редактирования\n\nexport const refreshArticlesRequest = createAction('REFRESH_ARTICLES_REQUEST'); // обновить список постов\n\nexport const refreshArticles = () => async dispatch => {\n  dispatch(createArticleFailure());\n  dispatch(refreshArticlesRequest());\n}; // изменить профиль пользователя\n\nexport const editUserProfileRequest = createAction('EDIT_USER_PROFILE_REQUEST');\nexport const editUserProfileSuccess = createAction('EDIT_USER_PROFILE_SUCCESS');\nexport const editUserProfileFailure = createAction('EDIT_USER_PROFILE_FAILURE');\nexport const editUserProfile = (userData, formik) => async dispatch => {\n  dispatch(editUserProfileRequest());\n\n  try {\n    const response = await api.editUserProfile(userData, formik);\n    dispatch(editUserProfileSuccess(response));\n  } catch (error) {\n    dispatch(editUserProfileFailure());\n    throw error;\n  }\n};\nexport const editArticleRequest = createAction('EDIT_ARTICLE_REQUEST');\nexport const editArticleSuccess = createAction('EDIT_ARTICLE_SUCCESS');\nexport const editArticleFailure = createAction('EDIT_ARTICLE_FAILURE');\nexport const editArticle = (articleData, formik) => async dispatch => {\n  dispatch(editArticleRequest());\n\n  try {\n    const response = 0;\n    dispatch(editArticleSuccess(response));\n  } catch (error) {\n    dispatch(editArticleFailure);\n    throw error;\n  }\n};","map":{"version":3,"sources":["C:/Users/stalk/jm-blog-platform/src/redux/actions/index.js"],"names":["createAction","api","signUpRequest","signUpSuccess","signUpFailure","signUp","newUserData","formik","dispatch","signUpProcess","err","signInRequest","signInSuccess","signInFailure","signIn","userData","responseUserData","signInProcess","logOutSuccess","getArticlesProcess","getArticlesSuccess","getArticles","currentArticlesCounter","fetchArticles","articlesPerRequest","counter","response","articles","articlesCount","length","error","console","log","createArticleRequest","createArticleSuccess","createArticleFailure","createArticle","articleBody","getOneArticleRequest","getOneArticleSuccess","getOneArticleFailure","getOneArticle","queryParam","refreshArticlesRequest","refreshArticles","editUserProfileRequest","editUserProfileSuccess","editUserProfileFailure","editUserProfile","editArticleRequest","editArticleSuccess","editArticleFailure","editArticle","articleData"],"mappings":"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","sourcesContent":["import { createAction } from 'redux-actions';\nimport * as api from '../../API';\n\nexport const signUpRequest = createAction('SIGN_UP_REQUEST');\nexport const signUpSuccess = createAction('SIGN_UP_SUCCESS');\nexport const signUpFailure = createAction('SIGN_UP_FAILURE');\n\n// регистрация\nexport const signUp = (newUserData, formik) => async (dispatch) => {\n  dispatch(signUpRequest());\n  try {\n    await api.signUpProcess(newUserData, formik);\n    dispatch(signUpSuccess());\n  } catch (err) {\n    dispatch(signUpFailure());\n  }\n};\n\nexport const signInRequest = createAction('LOG_IN_REQUEST');\nexport const signInSuccess = createAction('LOG_IN_SUCCESS');\nexport const signInFailure = createAction('LOG_IN_FAILURE');\n\n// авторизация\nexport const signIn = (userData, formik) => async (dispatch) => {\n  dispatch(signInRequest());\n  try {\n    const responseUserData = await api.signInProcess(userData, formik);\n    dispatch(signInSuccess(responseUserData));\n  } catch (err) {\n    dispatch(signInFailure());\n  }\n};\n\nexport const logOutSuccess = createAction('LOGOUT_SUCCESS');\n\nexport const getArticlesProcess = createAction('GET_ARTICLES_PROCESS');\nexport const getArticlesSuccess = createAction('GET_ARTICLES_SUCCESS');\n// при запросе на сервер статьи возвращаются пачками размером articlesPerRequest\n// в ответе приходит { articles: [], articlesCount: value }\n// массив articles диспатчим, чтобы не ждать от сервера все статьи(вдруг их тысячи)\n// Каждую итерацию сравниваем уже полученное число статей и кол-во на сервере\n// если на сервере статьи еще есть, то на фоне делаем запросы для их получения\n\nexport const getArticles = () => async (dispatch) => {\n  let currentArticlesCounter = 0;\n\n  const fetchArticles = async (articlesPerRequest = 100, counter = 0) => {\n    const response = await api.getArticles(articlesPerRequest, counter);\n    const { articles, articlesCount } = response;\n    dispatch(getArticlesProcess(articles));\n\n    currentArticlesCounter += articles.length;\n    if (currentArticlesCounter < articlesCount) {\n      await fetchArticles(articlesPerRequest, currentArticlesCounter);\n    }\n    if (currentArticlesCounter === articlesCount) {\n      dispatch(getArticlesSuccess());\n    }\n  };\n\n  try {\n    await fetchArticles();\n  } catch (error) {\n    console.log(error.response);\n  }\n}\n\n// создать пост\nexport const createArticleRequest = createAction('CREATE_ARTICLE_REQUEST');\nexport const createArticleSuccess = createAction('CREATE_ARTICLE_SUCCESS');\nexport const createArticleFailure = createAction('CREATE_ARTICLE_FAILURE');\n\nexport const createArticle = (articleBody, formik) => async (dispatch) => {\n  dispatch(createArticleRequest());\n  try {\n    await api.createArticle(articleBody, formik);\n    dispatch(createArticleSuccess());\n  } catch (error) {\n    console.log(error);\n    dispatch(createArticleFailure());\n  }\n};\n\n// запросить 1 пост\n// этот экшен нужен, чтобы загрузить пост просматриваемый пользователем\n// если он вбивает ссылку на пост в адресной строке\nexport const getOneArticleRequest = createAction('GET_ONE_ARTICLE_REQUEST');\nexport const getOneArticleSuccess = createAction('GET_ONE_ARTICLE_SUCCESS');\nexport const getOneArticleFailure = createAction('GET_ONE_ARTICLE_FAILURE');\n\nexport const getOneArticle = (queryParam) => async (dispatch) => {\n  dispatch(getOneArticleRequest());\n  try {\n    const response = await api.getOneArticle(queryParam);\n    dispatch(getOneArticleSuccess(response));\n  } catch (error) {\n    dispatch(getOneArticleFailure());\n    throw error;\n  }\n}\n\n// обновить посты после создания нового поста / удаления / редактирования\nexport const refreshArticlesRequest = createAction('REFRESH_ARTICLES_REQUEST');\n\n// обновить список постов\nexport const refreshArticles = () => async (dispatch) => {\n  dispatch(createArticleFailure());\n  dispatch(refreshArticlesRequest());\n};\n\n// изменить профиль пользователя\nexport const editUserProfileRequest = createAction('EDIT_USER_PROFILE_REQUEST');\nexport const editUserProfileSuccess = createAction('EDIT_USER_PROFILE_SUCCESS');\nexport const editUserProfileFailure = createAction('EDIT_USER_PROFILE_FAILURE');\n\nexport const editUserProfile = (userData, formik) => async (dispatch) => {\n  dispatch(editUserProfileRequest());\n  try {\n    const response = await api.editUserProfile(userData, formik);\n    dispatch(editUserProfileSuccess(response));\n  } catch (error) {\n    dispatch(editUserProfileFailure());\n    throw error;\n  }\n};\n\nexport const editArticleRequest = createAction('EDIT_ARTICLE_REQUEST');\nexport const editArticleSuccess = createAction('EDIT_ARTICLE_SUCCESS');\nexport const editArticleFailure = createAction('EDIT_ARTICLE_FAILURE');\n\nexport const editArticle = (articleData, formik) => async (dispatch) => {\n  dispatch(editArticleRequest());\n\n  try {\n    const response = 0;\n    dispatch(editArticleSuccess(response));\n  } catch (error) {\n    dispatch(editArticleFailure);\n    throw error;\n  }\n}\n\n\n"]},"metadata":{},"sourceType":"module"}